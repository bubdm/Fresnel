using Envivo.Fresnel.Introspection;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Envivo.Fresnel.Observers
{

    /// <summary>
    /// Returns Observers for .NET objects & values
    /// </summary>
    public class ObserverCache 
    {

        private ObjectObserverMap _ObjectMap;
        private ObjectObserverMap _StaticDataObjectMap;
        private ObjectObserverMap _NonReferenceMap;

        private List<ObjectObserver> _ObjectsForDisposal = new List<ObjectObserver>();
        private ObjectMerger _ObjectMerger;

        private IsObjectTrackableSpecification _IsObjectTrackableSpecification = new IsObjectTrackableSpecification();

        private static object s_syncLock = new object();

        internal event ObjectCreatedEventHandler ObjectCreated;
        internal event ObjectDisposedEventHandler ObjectDisposed;

        public ObserverCache(TemplateCache templateCache, ObserverBuilder observerBuilder, UserSession session)
        {
            if (templateCache == null)
                throw new ArgumentNullException("templateCache");

            if (observerBuilder == null)
                throw new ArgumentNullException("observerBuilder");

            this.TemplateCache = templateCache;
            this.ObserverBuilder = observerBuilder;
            this.Session = session;

            _ObjectMap = new ObjectObserverMap(this);
            _StaticDataObjectMap = new ObjectObserverMap(this);
            _NonReferenceMap = new ObjectObserverMap(this);

            _ObjectMerger = new ObjectMerger(templateCache, session);
            _ObjectMerger.FindMatchInTargetGraph += new ObjectMerger.FindMatchInTargetGraphHandler(ObjectMerger_FindMatchInTargetGraph);
        }

        void ObjectMerger_FindMatchInTargetGraph(object sender, ObjectMerger.ObjectRequestArgs args)
        {
            if (args.ObjectId == Guid.Empty)
                return;

            args.RealObject = _ObjectMap.GetRealObject(args.ObjectId);
        }

        /// <summary>
        /// The TemplateCache used by this ObserverCache
        /// </summary>
        internal TemplateCache TemplateCache { get; private set; }

        /// <summary>
        /// The ObserverBuilder used by this ObserverCache
        /// </summary>
        internal ObserverBuilder ObserverBuilder { get; private set; }

        /// <summary>
        /// A cache of mutable Observers that have been created during the lifetime of the application
        /// </summary>
        internal ObjectObserverMap Objects
        {
            get { return _ObjectMap; }
        }

        /// <summary>
        /// A cache of immutable Observers that have been created during the lifetime of the My.Application.
        /// This typically stores Observers for read-only objects.
        /// This cache doesn't get cleared down until the application is closed.
        /// </summary>
        internal ObjectObserverMap StaticDataObjects
        {
            get { return _StaticDataObjectMap; }
        }

        /// <summary>
        /// Changes the ID of the given Observer, and re-caches it with it's new key
        /// </summary>
        /// <param name="observer"></param>
        /// <param name="newId"></param>
        internal void ChangeObserverId(ObjectObserverBase observer, Guid newId)
        {
            if (_ObjectMap.DoesNotContain(observer.ID))
                return;

            _ObjectMap.Remove(observer.ID);

            observer.ID = newId;

            _ObjectMap.Add(observer.ID, observer);
        }

        /// <summary>
        /// Returns an ObjectObserver from the cache for the given Domain object
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        internal ObjectObserver GetObjectObserver(object obj)
        {
            if (obj == null)
            {
                throw new ArgumentNullException("obj");
            }

            var objectType = obj.GetRealType();
            if (objectType.IsNonReference())
            {
                throw new ArgumentOutOfRangeException("The given object cannot be a non-reference type");
            }

            // Make sure we return the ObjectObserver:
            return (ObjectObserver)this.GetObserver(obj, objectType);
        }

        /// <summary>
        /// Returns an Observer from the cache for the given object Type.
        /// </summary>
        /// <param name="obj">The Object to be observed</param>
        /// <param name="objectType">The Type of the Object to be observed</param>
        /// <returns>An Observer for the given Object</returns>
        /// <remarks>It is possible that the Object is 'Nothing', so the object Type is used to determine the correct Observer:</remarks>
        internal ObjectObserverBase GetObserver(object obj, Type objectType)
        {
            ObjectObserverBase oObject = null;

            //-----

            var template = this.TemplateCache.GetTemplate(objectType);
            var tClass = template as ClassTemplate;
            var isTrackable = (tClass != null && tClass.IsTrackable);

            var key = this.DetermineObjectID(obj, tClass);

            //-----

            if (obj == null)
            {
                oObject = this.ObserverBuilder.CreateObserver(obj, objectType, Guid.NewGuid());
            }
            if (oObject == null)
            {
                _ObjectMap.TryGetValue(key, out oObject);
            }
            if (oObject == null)
            {
                _StaticDataObjectMap.TryGetValue(key, out oObject);
            }

            //-----

            if (oObject == null)
            {
                // We need to create an new Observer and cache it:
                oObject = this.ObserverBuilder.CreateObserver(obj, objectType, key);

                if (oObject.IsNonReference)
                {
                    _NonReferenceMap.Add(oObject.ID, oObject);
                }
                else if (oObject.Template.IsStaticData)
                {
                    _StaticDataObjectMap.Add(oObject.ID, oObject);
                }
                else
                {
                    _ObjectMap.Add(oObject.ID, oObject);
                }

                if (this.ObjectCreated != null && isTrackable)
                {
                    // The consumer might want to run custom code when a new object comes into scope:
                    this.ObjectCreated(this, new ObjectArgs(oObject.RealObject));
                }
            }
            else if (isTrackable)
            {
                // We've been given a *different* Object with the same ID?
                if (object.ReferenceEquals(obj, oObject.RealObject) == false)
                {
                    System.Diagnostics.Debug.WriteLine("ReferenceEquals failed for " + oObject.DebugID);

                    // We should update the cached Object from the given instance.
                    // Note that we don't just replace the Object, as that would break 
                    // existing references to other Domain Objects in the graph:
                    if (oObject.IsCollection)
                    {
                        _ObjectMerger.MergeCollections(obj, oObject.RealObject);
                    }
                    else
                    {
                        _ObjectMerger.MergeValues(obj, oObject.RealObject);
                    }
                }
            }

            return oObject;
        }

        private Guid DetermineObjectID(object obj, ClassTemplate tClass)
        {
            Guid key = Guid.Empty;

            if (obj != null)
            {
                if (tClass != null && tClass.IdProperty != null)
                {
                    key = (Guid)tClass.IdProperty.GetValue(obj);
                }

                if (key == Guid.Empty)
                {
                    // We might already know about this non-trackable object
                    key = _ObjectMap.GetIdFor(obj);
                }
            }

            if (key == Guid.Empty)
            {
                // Looks like the Object cannot provide it's own ID:
                key = DomainTypes.Utils.GuidFactory.NewSequentialGuid();
                this.UpdateMissingObjectId(obj, tClass, key);
            }

            return key;
        }

        private void UpdateMissingObjectId(object obj, ClassTemplate tClass, Guid newId)
        {
            if (obj == null || tClass == null)
                return;

            if (tClass.IdProperty == null)
                return;

            tClass.IdProperty.SetValue(obj, newId);
        }

        /// <summary>
        /// Returns an Observer from the cache for the given object ID
        /// </summary>
        /// <param name="id">The unique Object ID</param>
        /// <param name="objectType"></param>
        /// <returns></returns>
        /// <remarks>Retrieves the object from the Persistence store</remarks>
        internal ObjectObserverBase GetObserver(Guid id, Type objectType)
        {
            return this.GetObserver(id, objectType.FullName);
        }

        internal ObjectObserverBase GetObserver(Guid id, string typeFullName)
        {
            var oObject = _ObjectMap.TryGetValueOrNull(id);

            if (oObject == null)
            {
                throw new TrueViewException(string.Format("Unable to find object [{0}] with ID [{1}]", typeFullName, id.ToString()));
            }

            if (oObject.RealObjectType.FullName.IsNotSameAs(typeFullName))
            {
                throw new TrueViewException(string.Format("Object [{0}] is of type [{1}]. Requested type was [{2}]", id.ToString(), typeFullName, oObject.RealObjectType.FullName));
            }

            return oObject;
        }

        /// <summary>
        /// Returns an Observer which represents an Null object for the given Type
        /// </summary>
        /// <param name="objectType"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        internal ObjectObserverBase GetObserver(Type objectType)
        {
            // "Null Object" pattern:
            ObjectObserverBase oNullObject = this.ObserverBuilder.CreateNullObserver(objectType);
            return oNullObject;
        }

        internal void RemoveObserver(ObjectObserverBase observer)
        {
            if (_ObjectMap.DoesNotContain(observer.ID))
                return;

            // Build a list of all Domain Objects to be purged from the Persistence Services:
            var oObject = observer as ObjectObserver;
            if (oObject != null && oObject.IsPersistable)
            {
                var oObjectsToPurge = new ObjectObserverCollection();
                oObjectsToPurge.Add(oObject);

                oObject.Persistor.Purge(oObjectsToPurge);
            }

            if (oObject != null)
            {
                // At some point, we need to properly Dispose of the objects that need to be GCed (eg events, resources, etc).
                // We'll do this later on, so remember which objects to cleanup:
                _ObjectsForDisposal.Add(observer.InnerObject);

                if (observer.RealObject is ObserverBase)
                {
                    throw new TrueViewException("Observer's must not contain other Observers");
                }
            }

            //Proxies.ProxyFactory.Remove(observer);
            lock (s_syncLock)
            {
                _ObjectMap.Remove(observer.ID);
            }
        }

        internal void RemoveObservers(IEnumerable<ObjectObserverBase> observers)
        {
            var assemblyToObjectMap = new Dictionary<System.Reflection.Assembly, ObjectObserverCollection>();

            foreach (var observer in observers)
            {
                if (observer.RealObject != null && _ObjectMap.DoesNotContain(observer.ID))
                    continue;

                // Build a list of all Domain Objects to be purged from the Persistence Services:
                var oObject = observer as ObjectObserver;
                if (oObject != null && oObject.IsPersistable)
                {
                    var oObjectsToPurge = assemblyToObjectMap.TryGetValueOrNull(oObject.RealObjectType.Assembly);
                    if (oObjectsToPurge == null)
                    {
                        oObjectsToPurge = new ObjectObserverCollection();
                        assemblyToObjectMap.Add(oObject.RealObjectType.Assembly, oObjectsToPurge);
                    }

                    oObjectsToPurge.Add(oObject);
                }

                if (oObject != null)
                {
                    // At some point, we need to properly Dispose of the objects that need to be GCed (eg events, resources, etc).
                    // We'll do this later on, so remember which objects to cleanup:
                    _ObjectsForDisposal.Add(observer.InnerObject);

                    if (observer.RealObject is ObserverBase)
                    {
                        throw new TrueViewException("Observer's must not contain other Observers");
                    }
                }
            }

            //-----
            // We now need to tell the appropriate Persistor to purge the Domain Objects:
            foreach (var item in assemblyToObjectMap)
            {
                var assembly = item.Key;
                var oObjectsToPurge = item.Value;

                var persistor = this.Session.InfrastructureServiceLocator.GetPersistorFor(assembly);
                persistor.Purge(oObjectsToPurge);
            }

            // We're finally in a position to remove the Observers
            foreach (var observer in observers)
            {
                lock (s_syncLock)
                {
                    _ObjectMap.Remove(observer.ID);
                }
            }

        }

        /// <summary>
        /// Removes unused Non-Reference observers from the cache
        /// </summary>
        /// <remarks></remarks>
        internal void CleanupNonReferenceCache()
        {
            lock (s_syncLock)
            {
                var nonRefsToDispose = new List<Guid>();

                foreach (var oNonRef in _NonReferenceMap.Values)
                {
                    if (oNonRef.UI.CanDispose == false)
                        continue;

                    if (oNonRef.ChangeTracker.CanDispose == false)
                        continue;

                    // Looks like we've got a disposable object:
                    nonRefsToDispose.Add(oNonRef.ID);
                }

                foreach (var id in nonRefsToDispose)
                {
                    _NonReferenceMap.Remove(id);
                }
            }
        }

        /// <summary>
        /// Removes unused Observers from the Observer cache
        /// </summary>
        internal void CleanupObjectCache()
        {
            lock (s_syncLock)
            {
                var observersToDispose = new List<ObjectObserverBase>();
                foreach (ObjectObserverBase observer in _ObjectMap.Values)
                {
                    if (observer.IsReferenceType &&
                        observer.InnerObject.IsReadyToDispose().Failed)
                    {
                        // The user is still viewing this Object:
                        continue;
                    }

                    if (observer.UI.CanDispose == false)
                    {
                        // The user is still viewing this Non-Reference value:
                        continue;
                    }

                    observersToDispose.Add(observer);
                }

                // Remove the invalid observers from the cache:
                this.RemoveObservers(observersToDispose);

                //#####
                // HACK: There may be some observers that should actually belong in the PinnedCache:
                // Basically, we're looking for Objects that are owned by other Objects that are marked with 'IsPinned=True'.
                // If the object is owned by a 'cached' object, it needs to be moved to the PinnedCache:
                this.MovePermanentObserversToCorrectCache();
            }
        }

        private void MovePermanentObserversToCorrectCache()
        {
            var objectsToPin = new List<ObjectObserverBase>();
            foreach (var oObject in _ObjectMap.Values)
            {
                ObjectObserver oOuterObject = null;

                if (oObject.OuterProperties.Count > 0)
                {
                    oOuterObject = oObject.OuterProperties[0].OuterObject;
                }
                else if (oObject.OuterCollections.Count > 0)
                {
                    oOuterObject = oObject.OuterCollections[0];
                }
                else if (oObject.IsObject)
                {
                    // We couldn't find any owners, so let's try the Object itself:
                    oOuterObject = oObject.InnerObject;
                }

                if ((oOuterObject != null) && (oOuterObject.Template.IsStaticData))
                {
                    // This Observer should belong in the static cache:
                    objectsToPin.Add(oObject);
                }
            }

            foreach (var oObject in objectsToPin)
            {
                _ObjectMap.Remove(oObject.ID);
                _StaticDataObjectMap.Add(oObject.ID, oObject);
            }
        }

        /// <summary>
        /// Performs disposal of all Domain Objects
        /// </summary>
        /// <remarks>
        /// NB: The object's Persistence Service MUST be detached, otherwise cleanup changes may be propagated to the Persistence store
        /// </remarks>
        internal void DisposeAllObjects()
        {
            foreach (var oObject in _ObjectsForDisposal)
            {
                var disposable = oObject.RealObject as IDisposable;
                if (disposable != null)
                {
                    disposable.Dispose();

                    // The consumer might want to run custom code when a new Object does out of scope:
                    if (this.ObjectDisposed != null)
                    {
                        this.ObjectDisposed(this, new ObjectArgs(oObject.RealObject));
                    }
                }

                oObject.Dispose();
            }

            _ObjectsForDisposal.Clear();
        }

        /// <summary>
        /// Detach all dirty objects so that they can be garbage collected
        /// </summary>
        /// <remarks></remarks>
        internal void DetachUnsavedObjects()
        {
            this.DetachUnsavedObjects(_ObjectMap.GetDirtyObjects());
        }

        /// <summary>
        /// Returns TRUE dirty objects exist within the cache
        /// </summary>
        /// <returns></returns>
        internal bool ContainsDirtyObjects()
        {
            return (_ObjectMap.GetDirtyObjects().Count > 0);
        }

        /// <summary>
        /// Detach any dirty objects from the given list, so that they can be garbage collected.
        /// This also ensures that the MemoryCache doesn't contain unpersisted Domain Objects
        /// </summary>
        /// <remarks></remarks>
        internal void DetachUnsavedObjects(IEnumerable<ObjectObserver> oObjects)
        {
            if (oObjects.Count() == 0)
                return;

            var objectsToRemove = new Dictionary<Guid, ObjectObserver>();

            foreach (var oObject in oObjects)
            {
                if (oObject.ChangeTracker.IsDirty == false)
                    continue;

                if (objectsToRemove.Contains(oObject.ID))
                    continue;

                if (oObject.IsReadyToDispose().Failed)
                    continue;

                objectsToRemove.Add(oObject.ID, oObject);
            }

            if (objectsToRemove.Count > 0)
            {
                // HACK: Haven't gotten to the bottom of this yet, but two passes are required to completely clean up:
                const short NUMBER_OF_PASSES = 2;
                for (var i = 1; i <= NUMBER_OF_PASSES; i++)
                {
                    foreach (var oObjectToRemove in objectsToRemove.Values)
                    {
                        oObjectToRemove.MakeOrphan();
                    }
                }
            }
        }

    }

}
